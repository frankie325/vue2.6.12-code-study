# 问题

## 为什么data，watch选项中，如果写的方法是箭头函数就访问不到实例的this了？
因为vue源码使用call或者apply方法对函数进行调用，如果使用箭头函数，call方法是无法改变箭头函数this的指向的。
## 多次绑定同一事件时？
当多次绑定同一事件时，如下click事件绑定了两次
```js
template = `<div v-on:click="handleClick1" v-on:click="handleClick2"></div>`
```
经过vue的编译器解析，我们知道在生成AST的时候，```makeAttrsMap```方法会对重复的属性进行警告。（两个事件还是会触发的）  
而使用下面的模板没有警告也只会触发第一个方法
```html
<template>
    <div v-on:click="handleClick1" v-on:click="handleClick2"></div>
</template>
```
这是因为直接写HTML，HTML对于相同的属性只保留最前面的，重复的属性去除掉了，所以当```$mount```中获取模板时实际只有```<div v-on:click="handleClick1"></div>```

如果想多次绑定同一事件时，可以在template这样写
```js
template = `<div v-on:click="handleClick1" @click="handleClick2"></div>`
template = `<div v-on:click="handleClick1();handleClick2()"></div>`
```

## v-cloak原理
在标签上添加```v-cloak```，模板解析没有对```v-cloak```进行任何处理，所以生成的标签不会有```v-cloak```属性，所以在模板解析过程中，可以使用css属性选择器```[v-clock]```来对还未渲染的模板进行隐藏，提高用户体验

## 组件上绑定属性
子组件上的属性会添加到组件的根标签，而作为props进行传递的属性是不会添加到根标签的

## $emit触发绑定事件时的this指向
因为绑定的事件时父组件传递进来的，所以this指向取决于传递进来的函数所在的上下文
一般我们都写methods选项中，因为vue使用了bind进行处理，所以会指向父组件实例

## 动态组件is绑定的值
is属性可以绑定成组件名称或者是组件构建对象或者组件构造函数，这三种情况会在```_createElement```渲染函数中进行处理，最后都会转成组件构造函数的形式